"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFont = void 0;
const process_1 = __importDefault(require("process"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importStar(require("fs"));
const json5_1 = __importDefault(require("json5"));
const subset_font_1 = __importDefault(require("subset-font"));
const lodash_kebabcase_1 = __importDefault(require("lodash.kebabcase"));
const fontkit_1 = __importDefault(require("fontkit"));
const hz_1 = require("./hz");
const skia_canvas_1 = require("skia-canvas");
const child_process_1 = __importDefault(require("child_process"));
const axios_1 = __importDefault(require("axios"));
function calcCharacterSpans(charsString) {
    const chSpanMap = [];
    let chSpan = { start: -1, count: 0 };
    for (let i = 0; i < charsString.length; i++) {
        let ch = charsString.charCodeAt(i);
        if (ch != chSpan.start + chSpan.count) {
            if (chSpan.start >= 0)
                chSpanMap.push({ start: chSpan.start, count: chSpan.count });
            (chSpan.start = ch), (chSpan.count = 1);
        }
        else {
            chSpan.count++;
        }
    }
    chSpanMap.push({ start: chSpan.start, count: chSpan.count });
    const calcCount = chSpanMap.reduce((p, c) => {
        p += c.count;
        return p;
    }, 0);
    console.log("charsString length", charsString.length);
    console.log("char span count", chSpanMap.length);
    console.log("calced chars count", calcCount);
    return chSpanMap;
}
async function writeSplitedFont(outoutDir, fontBuffer, fileName, strfonts) {
    try {
        const subsetBuffer = await (0, subset_font_1.default)(fontBuffer, strfonts, {
            targetFormat: "woff2",
        });
        await fs_1.default.promises.writeFile(path_1.default.join(outoutDir, fileName), subsetBuffer);
        console.log("ok:", fileName, subsetBuffer.length, "bytes");
    }
    catch (e) {
        console.log("Error:", fileName, e);
    }
}
async function buildCharsChunk(outputDir, fkFont, fontBuffer, name, charsStr, chunkCharsLimited, isFontDisplayBlock) {
    console.log("BUILD CHUNK:", name);
    const spans = calcCharacterSpans(charsStr);
    let charsCounter = 0;
    let charSpans = [];
    let chunksList = [];
    for (let sp of spans) {
        let spanPos = 0;
        while (true) {
            let availSpanSize = sp.count - spanPos;
            if (charsCounter + availSpanSize >= chunkCharsLimited) {
                let sz = chunkCharsLimited - charsCounter;
                charSpans.push({ start: sp.start + spanPos, count: sz });
                charsCounter += sz;
                chunksList.push(charSpans);
                spanPos += sz;
                charsCounter = 0;
                charSpans = [];
            }
            else {
                charSpans.push({ start: sp.start + spanPos, count: availSpanSize });
                charsCounter += availSpanSize;
                break;
            }
        }
    }
    if (charSpans.length > 0) {
        let chunkChars = charSpans.reduce((p, c) => {
            p += c.count;
            return p;
        }, 0);
        if (chunkChars < chunkCharsLimited / 2) {
            chunksList[chunksList.length - 1].push(...charSpans);
        }
        else {
            chunksList.push(charSpans);
        }
    }
    let cssText = "";
    for (let chunk of chunksList) {
        let chunkChars = chunk.reduce((p, c) => {
            p += c.count;
            return p;
        }, 0);
        const chunkName = `${name}_${chunk[0].start.toString(16)}_${chunkChars}`;
        console.log("chunk:", chunkName);
        const chunkFontFileName = `${chunkName}.woff2`;
        const strFonts = chunk
            .reduce((p, c) => {
            for (let i = 0; i < c.count; i++) {
                p.push(String.fromCharCode(c.start + i));
            }
            return p;
        }, [])
            .join("");
        console.log(strFonts);
        await writeSplitedFont(outputDir, fontBuffer, chunkFontFileName, strFonts);
        try {
            const fileSize = (await fs_1.default.promises.stat(path_1.default.join(outputDir, chunkFontFileName))).size;
            console.log("write OK", chunkFontFileName, fileSize);
        }
        catch (e) {
            console.log("error:", e.message);
            process_1.default.exit(1);
        }
        const cssRange = chunk
            .map((v) => v.count > 1 ? `U+${v.start.toString(16)}-${(v.start + v.count).toString(16)}` : `U+${v.start.toString(16)}`)
            .join(",")
            .toUpperCase();
        cssText += `@font-face {font-family: '${fkFont.familyName}';src: local('${fkFont.familyName}'), url('${chunkFontFileName}');unicode-range: ${cssRange};}\n`;
    }
    return cssText;
}
async function writePackageJson(buildFontPath, fontConfig, fkFont) {
    const packageJson = {
        name: fontConfig.fontPkgName,
        description: fontConfig.description,
        version: fontConfig.version,
        repository: "https://github.com/wc-ex/cn-fontsource",
        keywords: ["cn", "cnfont", "cn-font", "fontsource", fontConfig.name],
        font: {
            name: fontConfig.name,
            type: fontConfig.type,
            fontClass: fontConfig.fontClass,
            link: fontConfig.link,
            version: fkFont.version,
            familyName: fkFont.familyName,
            subfamilyName: fkFont.subfamilyName,
            copyright: fkFont.copyright,
            characterCount: fkFont.characterSet.length,
        },
        license: fontConfig.license,
    };
    fs_1.default.writeFileSync(path_1.default.join(buildFontPath, "package.json"), JSON.stringify(packageJson, null, 2));
}
async function writePackageReadme(buildFontPath, fontConfig, fkFont) {
    const readme = `![${fontConfig.name}](https://cdn.jsdelivr.net/npm/${fontConfig.fontPkgName}@${fontConfig.version}/font.png)

### ${{ free: "非开源,免费商用", opensource: "开源字体-推荐使用", paid: "商业字体" }[fontConfig.type] || "商业或未知"}
> LICENSE: ${fontConfig.license}

适用于浏览器的多片段快速加载的中文字库
- ${fontConfig.description}
- 参见:  ${fontConfig.link}
- 更多字体: WEB在线中文字体搜集:  https://github.com/wc-ex/cn-fontsource

![demo](https://cdn.jsdelivr.net/npm/${fontConfig.fontPkgName}@${fontConfig.version}/demo.png)

### 信息
- version: ${fkFont.version}
- familyName: ${fkFont.familyName}
- subfamilyName: ${fkFont.subfamilyName}
- fullName: ${JSON.stringify(fkFont.fullName)}
- characterCount: ${fkFont.characterSet.length}

### 使用
- CDN 直接调用
  \`\`\`html
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/${fontConfig.fontPkgName}/font.css"></link>
  <style>
    html{
      font-family: Roboto, "${fkFont.familyName}", sans-serif;
    }
  </style>
  \`\`\`
- 本地化
  > npm i ${fontConfig.fontPkgName}

  > 加载: font.css

`;
    fs_1.default.writeFileSync(path_1.default.join(buildFontPath, "README.md"), readme);
}
async function writeTextPng(fontFileName, buildFontPath, fontConfig, fkFont, lines, toFile) {
    const PADDING = 10;
    skia_canvas_1.FontLibrary.use(fkFont.familyName, [fontFileName]);
    let canvas1 = new skia_canvas_1.Canvas(100, 100);
    const ctx1 = canvas1.getContext("2d");
    let calcLines = lines.map((v) => {
        ctx1.font = `${v.size}px "${fkFont.familyName}"`;
        return { ...v, ...ctx1.measureText(v.text) };
    });
    let maxWidth = Math.max(...calcLines.map((v) => v.width));
    let maxHeight = calcLines.reduce((p, c) => {
        return p + c.fontBoundingBoxAscent + c.fontBoundingBoxDescent + PADDING;
    }, 0);
    console.log("width:", maxWidth, "height:", maxHeight);
    let canvas2 = new skia_canvas_1.Canvas(maxWidth + 20, maxHeight + 20);
    const ctx2 = canvas2.getContext("2d");
    let yPos = PADDING;
    for (let l of calcLines) {
        ctx2.font = `${l.size}px "${fkFont.familyName}"`;
        ctx2.fillStyle = "rgb(0,0,0)";
        let x = PADDING + (maxWidth - l.width) / 2;
        let y = yPos + l.fontBoundingBoxAscent;
        ctx2.fillText(l.text, x, y);
        yPos += l.fontBoundingBoxAscent + l.fontBoundingBoxDescent + PADDING;
    }
    canvas2.saveAsSync(path_1.default.join(buildFontPath, toFile), { format: "png" });
}
async function checkExistNpm(pkgName, version) {
    let ret = await axios_1.default.get(`https://registry.npmjs.com/${pkgName}`, { responseType: 'json',
        validateStatus(status) {
            return status < 500;
        },
    });
    if (ret.status == 404) {
        return;
    }
    else {
        if (ret.data.versions[version])
            throw Error(`Npm existd ${pkgName}, ${version},please upgrade version or change name`);
    }
}
function readSc(file) {
    return JSON.parse(fs_1.default.readFileSync(path_1.default.join(__dirname, file), "utf8"));
}
async function buildFont(fontDir, fontName) {
    console.log(`---- font file: ${fontName} ----`);
    let fontConfig = json5_1.default.parse(await fs_1.promises.readFile(path_1.default.join(fontDir, "font.json5"), "utf8"));
    console.log("  ==> ", fontConfig.name);
    let fontFileName = path_1.default.join(fontDir, fontName);
    let fkFont = fontkit_1.default.openSync(fontFileName);
    if (!fkFont)
        throw Error("open font failed: " + fontName);
    console.log("  ==> ", fkFont.familyName, ",", fkFont.subfamilyName, ",", fkFont.fullName, ",", fkFont.numGlyphs);
    fontConfig.fontPkgName = `cn-fontsource-${(0, lodash_kebabcase_1.default)(fkFont.familyName + "-" + fkFont.subfamilyName + (fontConfig.ext ? "-" + fontConfig.ext : ""))}`;
    await checkExistNpm(fontConfig.fontPkgName, fontConfig.version);
    let buildFontPath = path_1.default.resolve("./tmp", fontConfig.name, fontConfig.fontPkgName);
    if (fs_1.default.existsSync(buildFontPath))
        fs_1.default.rmSync(buildFontPath, { recursive: true });
    fs_1.default.mkdirSync(buildFontPath, { recursive: true });
    console.log("  OUTPUT: ==> ", buildFontPath);
    let fontBuffer = await fs_1.promises.readFile(fontFileName);
    let hz = (0, hz_1.makeHZ)(fkFont);
    let css = "";
    css += await buildCharsChunk(buildFontPath, fkFont, fontBuffer, "L1", hz.L1, 192, false);
    css += await buildCharsChunk(buildFontPath, fkFont, fontBuffer, "L2", hz.L2, 96, false);
    css += await buildCharsChunk(buildFontPath, fkFont, fontBuffer, "L3", hz.L3, 64, false);
    console.log(`  END ==>  ${fontName} \n`);
    fs_1.default.writeFileSync(path_1.default.join(buildFontPath, "font.css"), css, "utf8");
    await writeTextPng(fontFileName, buildFontPath, fontConfig, fkFont, [{ size: 48, text: fontConfig.name }], "font.png");
    let sc = [
        ...readSc("sc0.json"),
        ...readSc("sc1.json"),
        ...readSc("sc2.json"),
        ...readSc("sc3.json"),
        ...readSc("sc4.json"),
        ...readSc("sc5.json"),
        ...readSc("sc6.json"),
        ...readSc("sc7.json"),
        ...readSc("sc8.json"),
        ...readSc("sc9.json"),
        ...readSc("sc10.json"),
    ];
    let n = Math.round(Math.random() * sc.length);
    await writeTextPng(fontFileName, buildFontPath, fontConfig, fkFont, [
        { size: 48, text: sc[n].rhythmic },
        { size: 24, text: sc[n].author },
        ...sc[n].paragraphs.map((v) => {
            return { size: 32, text: v };
        }),
    ], "demo.png");
    await writePackageJson(buildFontPath, fontConfig, fkFont);
    await writePackageReadme(buildFontPath, fontConfig, fkFont);
    console.log("  ==> SUCCEED BUILD");
    child_process_1.default.execSync(`npm --registry \"https://registry.npmjs.org/\" publish --access public`, {
        cwd: buildFontPath,
        stdio: "inherit",
    });
    console.log("== SUCCEED PUBLISH NPM == ");
}
exports.buildFont = buildFont;
